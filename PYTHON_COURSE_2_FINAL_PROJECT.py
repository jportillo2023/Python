
# Ejemplos de lineas dentro del log file:
May 27 11:45:40 ubuntu.local ticky: INFO: Created ticket [#1234] (username)
Jun  1 11:06:48 ubuntu.local ticky: ERROR: Connection to DB failed (username)

# Se piden dos tipos de reporte:
#
# 1.- "Ranking of the errors generated by the Ticky system" (a list of all ERROR messages logged and how 
#   many times each of them was found, not taking into account the users involved). The list have to show:  
#   from the most commun errors to the least commun errors.
#
# 2.- "Usage statistics for the server" (a list of all users that have used the system including how many INFO and how many ERROR 
#   massages they have generated). The report has to be ordered by username.
#

# Expresion regular para detectar los errores en el syslog:
resp = re.search(r"ticky: ERROR: (.+) \(", "Jun  1 11:06:48 ubuntu.local ticky: ERROR: Connection to DB failed (username)")
resp[1]
'Connection to DB failed'



# Script BASH de ejemplo:
#
#!/bin/bash

log_file=$1

if [ -e $log_file ]; then
    `./errors_users_reports.py $log_file`
else
    echo "Log file does not exist!"
fi




# Script PYTHON de ejemplo:
#
#!/usr/bin/env python

import csv
import os
import re
import sys


def process_log_file(log_file_name):
    error_messages = {}   # <---- formato {"mensaje de error leido": <contador>, .....}
    user_registers = {}   # <---- formato {"user name": [<contador INFO>, <contador ERROR>],..}

    #error_pattern = r"ticky: ERROR: (.+) \("
    #info_pattern  = r"ticky: INFO: (.+) \("
    pattern = r"ticky: (ERROR?|INFO?): (.+) \((\w+)\)"   # CAPTURE GROUPS: messaje type, message and username

    with open(log_file_name, "r") as file:
        lines = file.readlines()

        for line in lines:
            resp = re.search(pattern, line)

            # Check if log entry is a "ticky" messaje.
            if resp != None:
                message = resp[1]    # Take the message type.
                username = resp[3]   # Take the username.

                # ------- Fill ERROR messages dictionary ------- #
                if "ERROR" in message:
                    if error_messages[errorMsg]:
                        error_messages[errorMsg] += 1   # Error exist. Increment error counter.
                    else:
                        error_messages[errorMsg] = 1    # New error element.
                # ------- Fill ERROR messages dictionary ------- #

                # ------------ Fill USERS dictionary ----------- #
                if username not in user_registers:
                    # Create user element.abs
                    user_registers[username] = [0, 0]
                else:
                    if "ERROR" in message:
                        user_registers[username][1] += 1   # Increment user's ERROR counter
                    if "INFO" in message:
                        user_registers[username][0] += 1   # Increment user's INFO counter
                # ------------ Fill USERS dictionary ----------- #

        file.close()

    # Verify if any "ticky" message was processed.
    if error_messages.keys():
        # Sort ERROR dictionary from the most commun error message to the least one.
        error_messages = dict(sorted(error_messages.items(), key=lambda x : x[1], reverse=True))
        # IMPORTANTE: Revisar https://www.freecodecamp.org/news/sort-dictionary-by-value-in-python/

        # Create the reports.
        write_error_report(error_messages)   # Build the Error Report.
        write_user_report(user_registers)    # Build the User Report.


#
# Errors Report:
#
def write_error_report(error_messages):
    errors_report_name = "errors_report.csv"

    with open(errors_report_name, mode='w') as csv_file:
        fieldnames = ['ERROR','OCURRENCES']
        writer = csv.DictWriter(csv_file, fieldnames=fieldnames)
        writer.writeheader()
        writer.writerow({'Connection to DB failed': '30'})    # OJO: Como escribimos un elemento de este diccionario????

### PROCEDIMIENTO "manual" de escritura de un diccionario a CSV:
# Diccionario de ejemplo:
error_messages = {"Connection to DB failed": 2, "network timeout": 20, "file not found": 8}

# Se debe convertir de nuevo en diccionario porque la funcion "sorted" devuelve un iterable tipo lista!
error_messages = dict(sorted(error_messages.items(), key=lambda x : x[1], reverse=True))

with open("error_report.csv", "w", newline="") as output_file:
    writer = csv.writer(output_file, delimiter=',')
    writer.writerow(["Ocurrences", "Error Message"])
    for key, value in error_messages.items():
        writer.writerow([value, key])


#
# Users Report:
#
def write_user_report(user_dictionary):
    users_report_name = "users_report.csv"

    with open(users_report_name, mode='w') as csv_file:
        fieldnames = ['USER', 'INFO', 'ERROR']
        writer = csv.DictWriter(csv_file, fieldnames=fieldnames)
        writer.writeheader()
        writer.writerow({'Franz': ['30', '2']})    # OJO: Como escribimos un elemento de este diccionario????

### PROCEDIMIENTO "manual":
user_messages = {"dcabello": [4, 1], "mmachado": [10, 3], "nmaduro": [2, 0]}

with open("users_report.csv", "w", newline="") as output_file:
    writer = csv.writer(output_file, delimiter=',')
    writer.writerow(["User", "INFO", "ERROR"])
    for key, value in user_messages.items():
        writer.writerow([key, value[0], value[1]])


# Este es un ejemplo de escritura de diccionario de listas.
# Tomado de: https://stackoverflow.com/questions/23613426/write-dictionary-of-lists-to-a-csv-file
d = {"key1": [1,2,3], "key2": [4,5,6], "key3": [7,8,9]}

keys = sorted(d.keys())

with open("test.csv", "wb") as outfile:
   writer = csv.writer(outfile, delimiter = "\t")
   writer.writerow(keys)
   writer.writerows(zip(*[d[key] for key in keys]))

Result:
key1    key2    key3
1       4       7
2       5       8
3       6       9



if __name__ == "__main__":
    log_file_name = sys.argv[1]
    log_file_name.strip()
    process_log_file(log_file_name)
    sys.exit(0)


